import { Edge, Node } from '@xyflow/react';

export function generateCode(nodes: Node[], edges: Edge[]) {
	let code = `
/*
 * This code was generated by Microflow studio.
 *
 * No warranty is provided.
 */
`;

	code += addImports();

	let innerCode = ``;

	innerCode += addBoard();

	const boardListners = ['error', 'fail', 'warn', 'exit', 'close', 'info'];
	boardListners.forEach(listener => {
		innerCode += addBoardListener(listener);
	});

	innerCode += addBoardListener('ready', false);
	nodes.forEach(node => {
		node.data.id = node.id; // Expose the Id to the options
		innerCode += `  const ${node.type}_${node.id} = new ${node.type}(${JSON.stringify(node.data)});`;
		innerCode += addEnter();
	});
	innerCode += addEnter();

	innerCode += `  const nodes = [${nodes.map(node => `{ id: "${node.type}_${node.id}", variable: ${node.type}_${node.id} }`)}];`;
	innerCode += addEnter();
	innerCode += addEnter();

	const nodesWithActionListener = nodes.filter(node =>
		edges.some(edge => edge.source === node.id),
	);

	nodesWithActionListener.forEach(node => {
		const actions = edges.filter(edge => edge.source === node.id);

		const actionsGroupedByHandle = actions.reduce(
			(acc, action) => {
				if (!acc[action.sourceHandle]) {
					acc[action.sourceHandle] = [];
				}

				acc[action.sourceHandle].push(action);

				return acc;
			},
			{} as Record<string, Edge[]>,
		);

		Object.entries(actionsGroupedByHandle).forEach(([action, edges]) => {
			innerCode += `  ${node.type}_${node.id}.on("${action}", () => {`;
			innerCode += addEnter();

			edges.forEach(edge => {
				const targetNode = nodes.find(node => node.id === edge.target);
				// TODO: maybe be a bit more specific about the value and also include the type?
				const shouldSetValue = [
					'set',
					'check',
					'red',
					'green',
					'blue',
					'opacity',
					'from',
					'publish',
					'rotate',
					'to',
				].includes(edge.targetHandle);
				let value = shouldSetValue
					? `${node.type}_${node.id}.value`
					: undefined;

				if (node.type === 'RangeMap' && shouldSetValue) {
					// Mapper node
					innerCode += addEnter();
					value = `${node.type}_${node.id}.value[1]`;
				}

				// TODO: add support for increment and decrement bigger than 1
				// TODO: add support for multiple values
				innerCode += `    ${targetNode?.type}_${targetNode?.id}.${edge.targetHandle}(${value});`;
				innerCode += addEnter();
			});

			innerCode += `  }); // ${node.type}_${node.id} - ${action}`;
			innerCode += addEnter();
			innerCode += addEnter();
		});
	});

	innerCode += addNodeProcessListener();
	innerCode += `}); // board - ready`;

	code += wrapInTryCatch(innerCode);

	const classDefinitions = [
		defineButton,
		defineFigma,
		defineLed,
		defineMqtt,
		defineSensor,
		defineServo,
		definePiezo,
	];

	classDefinitions.forEach(defineClass => {
		code += addEnter();
		code += defineClass();
	});

	return code;
}

function addEnter() {
	return `
`;
}

function addImports() {
	return `
const { Counter, IfElse, RangeMap, Interval } = require("@microflow/components");
const EventEmitter = require("events");
const JohnnyFive = require("johnny-five");
const log = require("electron-log/node");
`;
}

function addBoard() {
	return `
const board = new JohnnyFive.Board({
  repl: false,
  debug: false,
});
`;
}

function addBoardListener(type: string, selfClosing = true) {
	const pins =
		type === 'ready'
			? `, pins: Object.entries(board.pins).reduce((acc, [key, value]) => {
    acc.push({ pin: Number(key), ...value, });
    return acc;
  }, [])
  `
			: ``;
	return `
board.on("${type}", (event) => {
  log.warn("board ${type}", { event });
  process.parentPort.postMessage({ type: "${type}", message: event?.message${pins} });
${selfClosing ? `}); // board - ${type}` : ``}
`;
}

function addNodeProcessListener() {
	let code = `
process.parentPort.on('message', (e) => {`;

	let innerCode = ``;

	innerCode +=
		'const node = nodes.find((node) => node.id === `${e.data.nodeType}_${e.data.nodeId}`);';
	innerCode += addEnter();
	innerCode += 'node?.variable.setExternal(e.data.value)';

	code += wrapInTryCatch(innerCode);

	code += `
}); // process.parentPort.on - 'message'`;
	code += addEnter();
	return code;
}

function wrapInTryCatch(code: string) {
	return `
try {
  ${code}
} catch(error) {
  log.error("something went wrong", { error });
}
`;
}

function defineButton() {
	return `
class Button extends JohnnyFive.Button {
  constructor(options) {
    super(options);
    this.options = options

    this.on("up", this.#postMessage.bind(this, "up"));
    this.on("down", this.#postMessage.bind(this, "down"));
    this.on("hold", this.#postMessage.bind(this, "hold"));
    this.on("change", this.#postMessage.bind(this, "change"));
  }

  get value() {
    return this.value;
  }

  #postMessage(action) {
    if (action !== "change") {
      this.emit("change", this.value);
    }

    process.parentPort.postMessage({ nodeId: this.options.id, action, value: this.value });
  }
}
`;
}

function defineLed() {
	return `
class Led extends JohnnyFive.Led {
  #eventEmitter = new EventEmitter();
  #value = 0

  constructor(options) {
    super(options);
    this.options = options;

    this.#eventEmitter.on("change", this.#postMessage.bind(this, "change"));
  }

  get value() {
    return this.#value;
  }

  // Highjack the on method
  // to allow for a custom actions
  on(action, callback) {
    if (!action) {
      this.#value = 1;
      super.on();
      this.#eventEmitter.emit("change");
      return;
    }

    this.#eventEmitter.on(action, callback);
  }


  off() {
    this.#value = 0;
    super.off();
    this.#eventEmitter.emit("change");
  }

  toggle() {
    this.#value = this.#value === 0 ? 1 : 0;
    super.toggle();
    this.#eventEmitter.emit("change");
  }

  #postMessage(action) {
    if (action !== "change") {
      this.emit("change", this.value);
    }

    process.parentPort.postMessage({ nodeId: this.options.id, action, value: this.#value });
  }
}
`;
}

function defineFigma() {
	return `
class Figma extends EventEmitter {
  #value = '';
  #defaultRGBA = { r: 0, g: 0, b: 0, a: 0 }

  constructor(options) {
    super();
    this.options = options;

    this.on("change", this.#postMessage.bind(this, "change"));
  }

  set value(value) {
    this.#value = value;
    this.emit("change", value);
  }

  get value() {
    return this.#value;
  }

  increment(amount = 1) {
    this.value += amount;
  }

  decrement(amount = 1) {
    this.value -= amount;
  }

  true() {
    this.value = true;
  }

  false() {
    this.value = false;
  }

  toggle() {
    this.value = !this.value;
  }

  set(value) {
    this.value = value;
  }

  setExternal(value) {
    this.#value = value;
  }

  red(value) {
    this.value = { ...this.#defaultRGBA, ...this.#value, r: Math.min(1, value / 255) };
  }

  green(value) {
    this.value = { ...this.#defaultRGBA, ...this.#value, g: Math.min(1, value / 255) };
  }

  blue(value) {
    this.value = { ...this.#defaultRGBA, ...this.#value, b: Math.min(1, value / 255) };
  }

  opacity(value) {
    this.value = { ...this.#defaultRGBA, ...this.#value, a: Math.min(1, value / 100) };
  }

  #postMessage(action) {
    if (action !== "change") {
      this.emit("change", this.value);
    }

    process.parentPort.postMessage({ nodeId: this.options.id, action, value: this.value });
  }
}
  `;
}

function defineMqtt() {
	return `
class Mqtt extends EventEmitter {
  #value = '';

  constructor(options) {
    super();
    this.options = options;

    this.on("change", this.#postMessage.bind(this, "change"));
    this.on("subscribe", this.#postMessage.bind(this, "subscribe"));
  }

  get value() {
    return this.#value;
  }

  set value(value) {
    this.#value = value;
    this.#postMessage("change");
  }

  setExternal(value) {
    this.value = value;
    this.emit("subscribe");
  }

  publish(message) {
    this.value = message;
  }

  #postMessage(action) {
    if (action !== "change") {
      this.emit("change", this.value);
    }

    process.parentPort.postMessage({ nodeId: this.options.id, action, value: this.value });
  }
}`;
}

function defineSensor() {
	return `
class Sensor extends JohnnyFive.Sensor {
  #value = 0;

  constructor(options) {
    super(options);
    this.options = options;

    this.on("change", () => {
      this.#value = this.raw;
      this.#postMessage("change");
    })
  }

  get value() {
    return this.#value;
  }

  #postMessage(action) {
    if (action !== "change") {
      this.emit("change", this.value);
    }

    process.parentPort.postMessage({ nodeId: this.options.id, action, value: this.value });
  }
}
`;
}

function defineServo() {
	return `
class Servo extends JohnnyFive.Servo {
  constructor(options) {
    super(options);
    this.options = options;

    this.on("move:complete", this.postMessage.bind(this, "complete"));
  }

  min() {
    super.min()
    this.postMessage("change");
  }

  max() {
    super.max();
    this.postMessage("change");
  }

  to(position) {
    if(isNaN(position)) return;

    super.to(position);
    this.postMessage("change");
  }

  rotate(speed = 0) {
    if(typeof speed === 'boolean') {
      speed = speed ? 1 : -1;
    }

    if(speed < 0.05 && speed > -0.05) {
      this.stop();
      return;
    }

    this.cw(speed);


    this.postMessage("change");
  }

  stop() {
    super.stop();
    this.postMessage("change");
  }

  postMessage(action) {
    if(!this.options) return;
    this.emit("change", this.value);

    process.parentPort.postMessage({ nodeId: this.options.id, action, value: this.value });
  }
}
`;
}

function definePiezo() {
	return `
class Piezo extends JohnnyFive.Piezo {
  #eventEmitter = new EventEmitter();
  #timeout = null;
  #value = false;

  constructor(options) {
    super(options);
    this.options = options;
  }

  get value() {
    return this.#value;
  }

  set value(value) {
    this.#value = value;
    this.postMessage("change");
    this.#eventEmitter.emit("change", value);
  }

  buzz() {
    this.stop();

    this.value = true;
    super.frequency(this.options.frequency, this.options.duration);

    setTimeout(() => {
      this.stop();
    }, this.options.duration);
  }

  stop() {
    super.stop();
    super.off();
    this.value = false;
  }

  play() {
    this.stop();

    this.value = true;
    super.play({
      song: this.options.song,
      tempo: this.options.tempo
    }, () => {
      this.value = false;
    });
  }

  postMessage(action) {
    if (action !== "change") {
      this.#eventEmitter.emit("change", this.value);
    }

    process.parentPort.postMessage({ nodeId: this.options.id, action, value: this.value });
  }
}
`;
}
