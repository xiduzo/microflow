import { Edge, Node } from '@xyflow/react';

export function isNodeTypeACodeType(type?: string) {
	if (!type) return false;
	return !['note'].includes(type.toLowerCase());
}

export function generateCode(nodes: Node<{ baseType?: string; id?: string }>[], edges: Edge[]) {
	let code = `
/*
 * This code was generated by Microflow studio.
 *
 * No warranty is provided.
 */
`;

	code += addImports();

	code += addEnter();
	code += `
const port = process.argv.at(-1);

if (!port) {
	console.warn('No port provided, johnny five usualy can handle this. This might cause unforseen behavior.');
}
`;

	code += addEnter();
	code += `const nodes = new Map();`;
	code += addEnter();

	let innerCode = ``;

	innerCode += addBoard();

	const boardListeners = ['error', 'fail', 'warn', 'exit', 'close', 'info'];
	boardListeners.forEach(listener => {
		innerCode += addBoardListener(listener);
	});

	innerCode += addBoardListener('ready', false);

	nodes.forEach(node => {
		node.data.id = node.id; // Expose the Id to the options
		innerCode += `const ${node.type}_${node.id} = new MicroflowComponents.${node.data.baseType ?? node.type}(${JSON.stringify(node.data)});`;
		innerCode += addEnter();
		innerCode += `nodes.set("${node.id}", ${node.type}_${node.id});`;
		innerCode += addEnter();
		innerCode += addEnter();
	});

	innerCode += addEnter();

	innerCode += `
	/*
	 * Initial triggers
     */`;
	nodes.forEach(node => {
		if (['gate', 'calculate'].includes(node.type!.toLowerCase())) {
			const trigger = `${node.type}_${node.id}.check(${getAllEdgesValues(node.id, edges, nodes)});`;
			innerCode += wrapInTryCatch(trigger);
			innerCode += addEnter();
		}
	});

	innerCode += addEnter();

	const nodesWithActionListener = nodes.filter(node => edges.some(edge => edge.source === node.id));

	innerCode += `
	/*
	 * Handlers
     */`;
	nodesWithActionListener.forEach(node => {
		const actions = edges.filter(edge => edge.source === node.id);

		const actionsGroupedByHandle = actions.reduce(
			(acc, action) => ({
				...acc,
				[String(action.sourceHandle)]: [...(acc[String(action.sourceHandle)] || []), action],
			}),
			{} as Record<string, Edge[]>,
		);

		// React to actions
		Object.entries(actionsGroupedByHandle).forEach(([action, actionEdges]) => {
			innerCode += `${node.type}_${node.id}.on("${action}", (value) => {`;

			actionEdges.forEach(edge => {
				const targetNode = nodes.find(node => node.id === edge.target);
				if (!targetNode) return;

				if (['gate', 'calculate'].includes(targetNode.type!.toLowerCase())) {
					innerCode += wrapInTryCatch(
						`${targetNode.type}_${targetNode.id}.check(${getAllEdgesValues(targetNode.id, edges, nodes)});`,
					);
					return;
				}

				innerCode += wrapInTryCatch(
					`${targetNode.type}_${targetNode.id}.${edge.targetHandle}(value);`,
				);
				innerCode += addEnter();
			});

			innerCode += `  }); // ${node.type}_${node.id} - ${action}`;
			innerCode += addEnter();
			innerCode += addEnter();
		});
	});

	innerCode += `}); // board - ready`;

	code += wrapInTryCatch(innerCode);

	code += addNodeProcessListener();

	// TODO: prettier formatting
	return code;
}

function addEnter() {
	return `
`;
}

function addImports() {
	return `const MicroflowComponents = require("@microflow/components");`;
}

function addBoard() {
	return `
const ipRegex = new RegExp(/^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])$/);

let connection = port;

if(ipRegex.test(String(port))) {
    connection = new MicroflowComponents.TcpSerial({
        host: port,
        port: 3030,
    });

    connection.on('close', e => {
        process.send({ type: "close", message: \`Connection lost to \${port}\` });
    })
}

const board = new MicroflowComponents.Board({
  repl: false,
  debug: false,
  port: connection,
});
`;
}

function addBoardListener(type: string, selfClosing = true) {
	const pins =
		type === 'ready'
			? `, pins: Object.entries(board.pins).reduce((acc, [key, value]) => {
    acc.push({ pin: Number(key), ...value, });
    return acc;
  }, [])
  `
			: ``;
	return `
board.on("${type}", (event) => {
  process.send({ type: "${type}", message: event?.message${pins} });
${selfClosing ? `}); // board - ${type}` : ``}
`;
}

function addNodeProcessListener() {
	let code = `
/*
 * Listen to events from electron
*/
process.on('message', (e) => {`;

	let innerCode = ``;

	innerCode += 'const node = nodes.get(e.data.nodeId);';
	innerCode += addEnter();
	innerCode += 'node?.setExternal?.(e.data.value);';

	code += wrapInTryCatch(innerCode);

	code += `
}); // process.parentPort.on - 'message'`;
	return code;
}

function wrapInTryCatch(code: string) {
	return `
try {
  ${code}
} catch(error) {
  console.error("something went wrong", { error });
}`;
}

/**
 * @returns {string} The values of the source node as a string array
 * @example `'[true, 5, 0, 'what']'`
 */
function getAllEdgesValues(nodeId: string, edges: Edge[], nodes: Node[]) {
	const values = edges
		.filter(edge => edge.target === nodeId)
		.map(edge => {
			const sourceNode = nodes.find(node => node.id === edge.source);
			if (!sourceNode) return 'undefined';

			if (sourceNode.type?.toLowerCase() === 'rangemap')
				return `${sourceNode.type}_${sourceNode.id}.value[1]`;

			return `${sourceNode.type}_${sourceNode.id}.value`;
		})
		.join(',');

	return `[${values}]`;
}
