import { Edge, Node } from '@xyflow/react';

export function isNodeTypeACodeType(type?: string) {
	if (!type) return false;
	return !['note'].includes(type.toLowerCase());
}

export function generateCode(nodes: Node[], edges: Edge[]) {
	let code = `
/*
 * This code was generated by Microflow studio.
 *
 * No warranty is provided.
 */
`;

	code += addImports();

	code += addEnter();
	code += `
const port = process.argv.at(-1);

if (!port) {
	log.warn(
		'No port provided, johnny five usualy can handle this. This might cause unforseen behavior.',
	);
}
`;

	code += addEnter();
	code += `const nodes = new Map();`;
	code += addEnter();

	let innerCode = ``;

	innerCode += addBoard();

	const boardListeners = ['error', 'fail', 'warn', 'exit', 'close', 'info'];
	boardListeners.forEach(listener => {
		innerCode += addBoardListener(listener);
	});

	innerCode += addBoardListener('ready', false);

	nodes.forEach(node => {
		node.data.id = node.id; // Expose the Id to the options
		innerCode += `  const ${node.type}_${node.id} = new MicroflowComponents.${node.type}(${JSON.stringify(node.data)});`;
		innerCode += addEnter();
		innerCode += `  nodes.set("${node.id}", ${node.type}_${node.id});`;
		innerCode += addEnter();
	});

	innerCode += addEnter();
	innerCode += addEnter();

	// Initial triggers
	nodes.forEach(node => {
		if (node.type?.toLowerCase() === 'gate') {
			const trigger = `  ${node.type}_${node.id}.check(${getAllEdgesValues(node.id, edges, nodes)});`;
			innerCode += wrapInTryCatch(trigger);
			innerCode += addEnter();
			innerCode += addEnter();
		}
	});

	const nodesWithActionListener = nodes.filter(node => edges.some(edge => edge.source === node.id));

	nodesWithActionListener.forEach(node => {
		const actions = edges.filter(edge => edge.source === node.id);

		const actionsGroupedByHandle = actions.reduce(
			(acc, action) => ({
				...acc,
				[String(action.sourceHandle)]: [...(acc[String(action.sourceHandle)] || []), action],
			}),
			{} as Record<string, Edge[]>,
		);

		// React to actions
		Object.entries(actionsGroupedByHandle).forEach(([action, actionEdges]) => {
			innerCode += `  ${node.type}_${node.id}.on("${action}", () => {`;

			actionEdges.forEach(edge => {
				const targetNode = nodes.find(node => node.id === edge.target);
				if (!targetNode) return;

				let value = `${node.type}_${node.id}.value`;

				if (node.type?.toLowerCase() === 'rangemap') {
					// Mapper node
					innerCode += addEnter();
					value = `${node.type}_${node.id}.value[1]`;
				}

				if (targetNode.type?.toLowerCase() === 'gate') {
					value = getAllEdgesValues(targetNode.id, edges, nodes);
					edge.targetHandle = 'check'; // Naughty override, make sure this is in line with the actual implementation
				}

				// TODO: add support for increment and decrement bigger than 1
				const handler = `${targetNode.type}_${targetNode.id}.${edge.targetHandle}(${value});`;
				innerCode += wrapInTryCatch(handler);
				innerCode += addEnter();
			});

			innerCode += `  }); // ${node.type}_${node.id} - ${action}`;
			innerCode += addEnter();
			innerCode += addEnter();
		});
	});

	innerCode += `}); // board - ready`;

	code += wrapInTryCatch(innerCode);

	code += addNodeProcessListener();

	// TODO: prettier formatting
	return code;
}

function addEnter() {
	return `
`;
}

function addImports() {
	return `
const MicroflowComponents = require("@microflow/components");
const log = require("electron-log/node");
`;
}

function addBoard() {
	return `
const ipRegex = new RegExp(/^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])$/);
const portIsIp = ipRegex.test(String(port));

let connection;

if(portIsIp) {
    connection = new MicroflowComponents.TcpSerial({
        host: port,
        port: 3030,
    });

    connection.on('close', e => {
        process.parentPort.postMessage({ type: "close", message: \`Connection lost to \${port}\` });
    })
}

const board = new MicroflowComponents.Board({
  repl: false,
  debug: false,
  port: connection || port,
});

log.info("Board is created", { port: board.port });
`;
}

function addBoardListener(type: string, selfClosing = true) {
	const pins =
		type === 'ready'
			? `, pins: Object.entries(board.pins).reduce((acc, [key, value]) => {
    acc.push({ pin: Number(key), ...value, });
    return acc;
  }, [])
  `
			: ``;
	return `
board.on("${type}", (event) => {
  log.info("board ${type}", { event });
  process.parentPort.postMessage({ type: "${type}", message: event?.message${pins} });
${selfClosing ? `}); // board - ${type}` : ``}
`;
}

function addNodeProcessListener() {
	let code = `
// Listen to events from electron
process.parentPort.on('message', (e) => {`;

	let innerCode = ``;

	innerCode += 'const node = nodes.get(e.data.nodeId);';
	innerCode += addEnter();
	innerCode += 'node?.setExternal?.(e.data.value);';

	code += wrapInTryCatch(innerCode);

	code += `
}); // process.parentPort.on - 'message'`;
	return code;
}

function wrapInTryCatch(code: string) {
	return `
try {
  ${code}
} catch(error) {
  log.error("something went wrong", { error });
}`;
}

/**
 * @returns {string} The values of the source node as a string array
 * @example `'[true, 5, 0, 'what']'`
 */
function getAllEdgesValues(nodeId: string, edges: Edge[], nodes: Node[]) {
	const values = edges
		.filter(edge => edge.target === nodeId)
		.map(edge => {
			const sourceNode = nodes.find(node => node.id === edge.source);
			return `${sourceNode?.type}_${sourceNode?.id}.value`;
		})
		.join(',');

	return `[${values}]`;
}
